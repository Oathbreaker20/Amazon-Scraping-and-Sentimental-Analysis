'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var inquirer = require('inquirer');

var PublishCommand = require('../../../commands/publish-command');

var Entity = require('../../../models/entity');

var CliStatus = require('../../../models/cli-status');

var HttpWrapper = require('../../../utils/http-wrapper');

var config = require('../../../config');

var DomainConfigStrategy = /*#__PURE__*/function () {
  function DomainConfigStrategy(context, result) {
    _classCallCheck(this, DomainConfigStrategy);

    this.context = context;
    this.result = result;
    this.context.authenticateUser();
    this.options = {
      hostname: config.host,
      headers: {
        Authorization: "Bearer ".concat(this.context.userToken)
      }
    };
    this.flags = context.getParsedFlags();
  }

  _createClass(DomainConfigStrategy, [{
    key: "setValue",
    value: function setValue(name, value) {
      var _this = this;

      this._validateDomain(value);

      if (this.flags['enable-ssl']) {
        return this.enableSsl(value);
      }

      return this._verifyDomainName(value).then(function (_ref) {
        var domain = _ref.domain;
        return _this.context.mdbConfig.setValue(name, domain);
      }).then(function () {
        return _this.context.mdbConfig.save();
      }).then(function () {
        return _this._publish();
      });
    }
  }, {
    key: "unsetValue",
    value: function unsetValue(name) {
      var _this2 = this;

      return this._unsetDomain().then(function (_ref2) {
        var url = _ref2.url;

        var type = _this2.context.mdbConfig.getValue('meta.type');

        if (type === Entity.Frontend) {
          _this2.context.mdbConfig.unsetValue(name);

          _this2.result.addAlert('blue', 'Info', "Your project is now available at: ".concat(url));
        } else if (type === Entity.Backend || type === Entity.Wordpress) {
          _this2.context.mdbConfig.setValue('domain', url);

          _this2.result.addAlert('yellow', 'Warning', "Since this is a ".concat(type, " project we had to reset your domain name to the default one. Your project is now available at: ").concat(url));
        }
      }).then(function () {
        return _this2.context.mdbConfig.save();
      });
    }
  }, {
    key: "_validateDomain",
    value: function _validateDomain(value) {
      if (!/^(?=.{4,255}$)([a-zA-Z0-9_]([a-zA-Z0-9_-]{0,61}[a-zA-Z0-9_])?\.){1,126}[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]$/.test(value)) {
        throw new Error('Invalid domain name. Do not add the http(s):// part. If you are using *.mdbgo.io subdomain, don\'t omit the .mdbgo.io part as it won\'t work without it.');
      }
    }
  }, {
    key: "enableSsl",
    value: function () {
      var _enableSsl = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(domain) {
        var http;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.options.path = "/project/certificate";
                this.options.data = JSON.stringify({
                  domainName: domain
                });
                this.options.headers['Content-Length'] = Buffer.byteLength(this.options.data);
                this.options.headers['Content-Type'] = 'application/json';
                http = new HttpWrapper();
                _context.next = 7;
                return http.post(this.options);

              case 7:
                this.result.addAlert('green', 'Success', 'Certificate successfully enabled. Now you need to configure your DNS in order to finalize the configuration.');

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function enableSsl(_x) {
        return _enableSsl.apply(this, arguments);
      }

      return enableSsl;
    }()
  }, {
    key: "_verifyDomainName",
    value: function () {
      var _verifyDomainName2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(value) {
        var _this3 = this;

        var available, prompt, inputPrompt;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._checkIfExists(value);

              case 2:
                available = _context2.sent;

                if (!available) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", {
                  domain: value
                });

              case 5:
                prompt = inquirer.createPromptModule();
                inputPrompt = prompt([{
                  type: 'text',
                  message: 'Enter new domain name',
                  name: 'domain',
                  validate: function validate(value) {
                    try {
                      _this3._validateDomain(value);
                    } catch (e) {
                      return e.message;
                    }
                    /* istanbul ignore next */


                    return _this3._checkIfExists(value).then(function (available) {
                      if (!available) {
                        return 'This name is already taken. Please choose a different one.';
                      }

                      return true;
                    });
                  }
                }]);
                inputPrompt.ui.activePrompt.render('This name is already taken. Please choose a different one');
                return _context2.abrupt("return", inputPrompt);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _verifyDomainName(_x2) {
        return _verifyDomainName2.apply(this, arguments);
      }

      return _verifyDomainName;
    }()
  }, {
    key: "_checkIfExists",
    value: function () {
      var _checkIfExists2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(value) {
        var http, result, _JSON$parse, available;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.options.path = "/project/domain/verify?domain=".concat(value);
                http = new HttpWrapper();
                _context3.next = 4;
                return http.get(this.options);

              case 4:
                result = _context3.sent;
                _JSON$parse = JSON.parse(result.body), available = _JSON$parse.available;
                return _context3.abrupt("return", available);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _checkIfExists(_x3) {
        return _checkIfExists2.apply(this, arguments);
      }

      return _checkIfExists;
    }()
  }, {
    key: "_unsetDomain",
    value: function () {
      var _unsetDomain2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var http, result;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                http = new HttpWrapper();
                this.options.path = "/project/update/".concat(this.context.mdbConfig.getValue('projectName'));
                this.options.headers['Content-Length'] = Buffer.byteLength(this.options.data);
                _context4.next = 5;
                return http.put(this.options);

              case 5:
                result = _context4.sent;

                if (!(result.statusCode >= 200 && result.statusCode <= 299)) {
                  _context4.next = 8;
                  break;
                }

                return _context4.abrupt("return", JSON.parse(result.body));

              case 8:
                throw new Error('Error unsetting your domain.');

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _unsetDomain() {
        return _unsetDomain2.apply(this, arguments);
      }

      return _unsetDomain;
    }()
  }, {
    key: "_publish",
    value: function _publish() {
      this.context.entity = this.context.mdbConfig.getValue('meta.type');
      var publish = new PublishCommand(this.context);
      return publish.execute();
    }
  }]);

  return DomainConfigStrategy;
}();

module.exports = DomainConfigStrategy;