'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var Context = require('./context');
/**
 * This is a class that decides which command to run based on provided arguments. It parses the <code>process.argv</code> array and
 * executes a command or throws an error. It's main methods are: <br>
 * <ul>
 *  <li> <code>parse()</code> </li>
 *  <li> <code>executeCommand()</code> </li>
 * </ul>
 */


var CommandInvoker = /*#__PURE__*/function () {
  function CommandInvoker() {
    _classCallCheck(this, CommandInvoker);

    this.entity = null;
    this.command = null;
    this.args = [];
    this.flags = [];
    /**
     * A collection of valid entities that can be provided as the first argument of the mdb command.
     *
     * @type {Set<string>}
     * @private
     */

    this._validEntities = new Set(['app', 'backend', 'blank', 'database', 'frontend', 'order', 'repo', 'starter', 'user', 'wordpress']);
    /**
     * A collection of valid commands that do not require an entity to be provided. It's the case when we make the
     *
     * <pre> $ mdb <command> </pre>
     *
     * call. The entity will be guessed based on the command used.
     *
     * @type {Set<string>}
     * @private
     */

    this._validNonEntityCommands = new Set(['help', 'update', 'version', 'register', 'login', 'logout', 'ls', 'init', 'get', 'rename', 'publish', 'delete', 'whoami', 'logs', 'kill', 'info', 'restart', 'run', 'config']);
    /**
     * A collection of valid flags that do not require neither an entity nor a command to be provided. It's the case when we make the
     *
     * <pre> $ mdb <flag> </pre>
     *
     * call. The entity and command will be guessed based on the flag used.
     *
     * @type {Set<string>}
     * @private
     */

    this._validFlagOnlyCommands = new Set(['-h', '--help', '-v', '--version']);
    /**
     * A collection of valid commands that are aliases to some other entity-command pair.
     *
     * @type {Set<string>}
     * @private
     */

    this._validAliasCommands = new Set(['starters', 'orders']);
    /**
     * An array of arguments (entity, command, args, flags) passed to the <code> mdb </code> command.
     *
     * @type {string[]}
     */

    this.argv = [];
  }
  /**
   * A method that does the main job which is parsing the arguments and selecting the proper entity, command, args and flags.
   *
   * Now, the command usage is as follows: <br>
   *
   *     <pre> mdb &lt;entity&gt; &lt;command&gt; [args] [flags] </pre>
   *
   * and the parsing logic goes like this (in <string>that</strong> order):
   *
   * <ol>
   *     <li> If the first argument is an entity, then the next argument must be a command. Then, all of the arguments until the first flag are args. The rest are flags. </li>
   *     <li> If the first argument is a non-entity command, then obviously it's a command. The entity is selected based on the entity-command mapping which is defined in the <code>_getDefaultEntityForCommand()</code> method and is just hardcoded. Again, all of the arguments until the first flag are args. The rest are flags. </li>
   *     <li> If the first argument is an alias, then resolve alias and select an entity-command pair. Again, this is hardcoded in the <code>_resolveAlias()</code> method. Again, all of the arguments until the first flag are args. The rest are flags. </li>
   *     <li> If the first argument is a flag-only command, then select the command using the <code>_getDefaultCommandForFlag()</code> method with hardcoded mapping. Based on that command, select the entity (from hardcoded mapping in <code>_getDefaultEntityForCommand()</code> method). Again, all of the arguments until the first flag are args. The rest are flags. </li>
   *     <li> If the first argument is not any of the above, throw an error </li>
   * </ol>
   *
   * @param {string[]} processArgv An array of arguments passed to the <code> mdb </code> command. It's <code> process.argv </code>
   * @throws If the first argument cannot be classified as an entity, a non-entity command, an alias or a flag-only command, throw an <code>Invalid command: mdb &lt;command&gt;</code> error.
   */


  _createClass(CommandInvoker, [{
    key: "parse",
    value: function parse(processArgv) {
      var _this = this;

      this.argv = processArgv.slice(2);

      var firstArg = this._consumeNext();

      if (this._isEntity(firstArg)) {
        var _this$flags;

        this.entity = firstArg;
        this.command = this._consumeNext();
        this.args = this._consumeUntil(function (next) {
          return _this._isFlag(next);
        });

        (_this$flags = this.flags).push.apply(_this$flags, _toConsumableArray(this.argv));
      } else if (this._isNonEntityCommand(firstArg)) {
        var _this$flags2;

        this.command = firstArg;
        this.entity = this._getDefaultEntityForCommand(this.command);
        this.args = this._consumeUntil(function (next) {
          return _this._isFlag(next);
        });

        (_this$flags2 = this.flags).push.apply(_this$flags2, _toConsumableArray(this.argv));
      } else if (this._isAliasCommand(firstArg)) {
        var _this$flags3;

        var _this$_resolveAlias = this._resolveAlias(firstArg);

        var _this$_resolveAlias2 = _slicedToArray(_this$_resolveAlias, 2);

        this.entity = _this$_resolveAlias2[0];
        this.command = _this$_resolveAlias2[1];
        this.args = this._consumeUntil(function (next) {
          return _this._isFlag(next);
        });

        (_this$flags3 = this.flags).push.apply(_this$flags3, _toConsumableArray(this.argv));
      } else if (this._isFlagOnlyCommand(firstArg)) {
        this.command = this._getDefaultCommandForFlag(firstArg);
        this.entity = this._getDefaultEntityForCommand(this.command);
        this.flags = this.argv.slice();
      } else if (firstArg === undefined) {
        this.command = 'help';
      } else {
        throw new Error("Invalid command: mdb ".concat(processArgv.slice(2).join(' ')));
      }
    }
    /**
     * If the `_validEntities` Set has this value, it's an entity.
     *
     * @param {string} arg
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_isEntity",
    value: function _isEntity(arg) {
      return this._validEntities.has(arg);
    }
    /**
     * If the `_validNonEntityCommands` Set has this value, it's a non-entity command.
     *
     * @param {string} arg
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_isNonEntityCommand",
    value: function _isNonEntityCommand(arg) {
      return this._validNonEntityCommands.has(arg);
    }
    /**
     * If the `_validAliasCommands` Set has this value, it's an alias.
     *
     * @param {string} arg
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_isAliasCommand",
    value: function _isAliasCommand(arg) {
      return this._validAliasCommands.has(arg);
    }
    /**
     * If it's a flag and the `_validFlagOnlyCommands` Set has this value, it's a flag-only command.
     *
     * @param arg
     * @returns {*|boolean}
     * @private
     */

  }, {
    key: "_isFlagOnlyCommand",
    value: function _isFlagOnlyCommand(arg) {
      return this._isFlag(arg) && this._validFlagOnlyCommands.has(arg);
    }
    /**
     * If it starts with a `-` it's a flag.
     * Throws error if flag contain `=` instead of space.
     *
     * @param {string} arg
     * @returns {boolean}
     * @throws Error
     * @private
     */

  }, {
    key: "_isFlag",
    value: function _isFlag(arg) {
      var isFlag = !!arg && arg.startsWith('-');
      if (isFlag && arg.includes('=')) throw new Error('Please use space instead of `=` on flags');
      return isFlag;
    }
    /**
     * Remove and return the first element of the current `argv` array.
     *
     * @returns {string}
     * @private
     */

  }, {
    key: "_consumeNext",
    value: function _consumeNext() {
      return this.argv.shift();
    }
    /**
     * Return but don't remove the first element from the current `argv` array
     *
     * @returns {string}
     * @private
     */

  }, {
    key: "_getNext",
    value: function _getNext() {
      return this.argv[0];
    }
    /**
     * A function that is applied to each element and if it returns `true` the element will be added to the returning collection.
     *
     * @typedef StopCondition
     * @function
     * @param {string} next
     * @return {boolean}
     */

    /**
     * Remove and return elements from the `argv` array until the `stopCondition` predicate function returns true or until there are still elements in the array.
     * As long as the `stopCondition` predicate returns `true`
     *
     * @param {StopCondition} stopCondition
     * @returns {string[]}
     * @private
     */

  }, {
    key: "_consumeUntil",
    value: function _consumeUntil(stopCondition) {
      var consumed = [];

      var next = this._getNext();

      while (!stopCondition(next) && next !== undefined) {
        consumed.push(this._consumeNext());
        next = this._getNext();
      }

      return consumed;
    }
    /**
     * A method that based on the selected command, imports the proper <code>Command</code> file and calls the <code>execute()</code> method on it.
     *
     * @async
     * @returns {Promise<void>}
     */

  }, {
    key: "executeCommand",
    value: function () {
      var _executeCommand = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var ctx, CommandClass, command;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                ctx = new Context(this.entity, this.command, this.args, this.flags);
                CommandClass = require(path.resolve(__dirname, 'commands', "".concat(this.command, "-command")));
                command = new CommandClass(ctx);
                _context.next = 6;
                return command.execute();

              case 6:
                _context.next = 15;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);

                if (!(_context.t0.message && _context.t0.message.toLowerCase().startsWith('cannot find module'))) {
                  _context.next = 14;
                  break;
                }

                throw new Error("Invalid command: ".concat(this.command));

              case 14:
                throw _context.t0;

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 8]]);
      }));

      function executeCommand() {
        return _executeCommand.apply(this, arguments);
      }

      return executeCommand;
    }()
  }, {
    key: "_getDefaultEntityForCommand",
    value: function _getDefaultEntityForCommand(command) {
      switch (command) {
        case 'config':
          return 'config';

        case 'logs':
        case 'kill':
          return 'backend';

        case 'help':
        case 'update':
        case 'version':
          return 'app';

        case 'whoami':
        case 'register':
        case 'login':
        case 'logout':
          return 'user';

        case 'delete':
        case 'get':
        case 'info':
        case 'init':
        case 'ls':
        case 'publish':
        case 'rename':
        case 'restart':
        case 'run':
          return '';

        default:
          throw new Error('Invalid command');
      }
    }
  }, {
    key: "_getDefaultCommandForFlag",
    value: function _getDefaultCommandForFlag(flag) {
      switch (flag) {
        case '-v':
        case '--version':
          return 'version';

        case '-h':
        case '--help':
          return 'help';

        default:
          throw new Error('Invalid command');
      }
    }
  }, {
    key: "_resolveAlias",
    value: function _resolveAlias(alias) {
      switch (alias) {
        case 'starters':
          return ['starter', 'ls'];

        case 'orders':
          return ['order', 'ls'];
      }
    }
  }]);

  return CommandInvoker;
}();

module.exports = CommandInvoker;